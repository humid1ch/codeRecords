/*
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。
例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。  
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

示例 1：
输入：numbers = [3,4,5,1,2]
输出：1

示例 2：
输入：numbers = [2,2,2,0,1]
输出：0

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
/*
题目思路：
    简单的思路：
    数组默认为升序的
    经过一次旋转即为，将 末元素提升到首元素位置，其他元素后移一位
    即，若旋转了，从头向尾遍历就会出现断层，即 某位的元素会小于前一位的元素，此时某位即为最小元素
    若没旋转，遍历一遍不会出现断层，则 末元素时必定大于首元素的，此时首元素即为最小元素
    但是还有一种情况：
    2 2 2 2 2 2 2 2 2 2 2 2 2，这种情况其实也被算入了 遍历一遍不会出现断层的时候
    遍历 没有出现断层，不是默认升序 就是 全相同，此时 首元素即为最小元素

    可由此判断
    
    官方用的二分，感觉没什么必要
*/

class Solution
{
public:
    int minArray(vector<int>& numbers)
    {
        vector<int>::iterator vit = numbers.begin() + 1;
        while(vit < numbers.end())
        {
            if(*vit < *(vit - 1))
                return *vit;
            if(vit < numbers.end())
                vit++;
        }

        return numbers[0];
    }
};
/*
设计一个算法，算出 n 阶乘有多少个尾随零。

示例 1:
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。

示例 2:
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.

说明: 你算法的时间复杂度应为 O(log n) 

来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/factorial-zeros-lcci
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/
/*
思路分析：
    思路1：
        最笨的思路：先计算出 数的阶乘, 再将算阶乘的尾有多少个0
        但是很明显 本题中无法实现, 因为数值溢出
    思路2：
        思路2 是看题解之后才理解的思路
        求阶乘的尾数中有多少个 0, 其实就是找 在求阶乘的过程中出现过多少次 10、20、30……
        这些十的倍数一定是 5 与 一个偶数相乘得到的
        求阶乘的过程中 偶数的数量一定比 5 的数量多
        比如 17! = 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10 * 11 * 12 * 13 * 14 * 15 * 16 * 17
        可以再细分为 
        1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 2*5 * 11 * 12 * 13 * 14 * 3*5 * 16 * 17
        又可以 将其中的 5 与 偶数 组合起来：
        1 * 3 * 4 * 2*5 * 6 * 7 * 8 * 9 * 2*5 * 11 * 12 * 13 * 3 * 14*5 * 16 * 17
        最终就可以得出：
        1 * 3 * 4 * 6 * 7 * 8 * 9 * 11 * 12 * 13 * 3 * 16 * 17 * 2*5 * 2*5 * 14*5 
        ↓↓↓↓↓↓
        1 * 3 * 4 * 6 * 7 * 8 * 9 * 11 * 12 * 13 * 3 * 16 * 17 * 10 * 10 * 70
        最终的可以得出的阶乘的尾数中有 3 个 0
        所以 求阶乘位数中有多少0 其实就是找 求阶乘过程中 出现过多少5
        像 25 125 等 这些数中 出现了 2个5 或 3个5 就需要计入 2 或 3
        怎么统计呢？
        重复对 n /= 5
        结果就是 求阶乘中出现一个 5 的次数
        除以 5 是为了计算 25 125 等这种情况
*/
class Solution {
public:
    // 思路1：(本题无法实现)
    /*int trailingZeroes(int n) {
        long long factorial = 1;
        int count = 0;
        for(int i = 1; i <= n; i++) {
            factorial *= i;
        }
        while(factorial > 0) {
            if(factorial % 10 != 0)
                break;
            else {
                count++;
                factorial /= 10;
            }
        }
        
        return count;
    }*/
    // 思路2：
    int trailingZeroes(int n) {
        int ret = 0;
        while(n >= 5) {
            n /= 5;
            ret += n;
        }
    
        return ret;
    }
};
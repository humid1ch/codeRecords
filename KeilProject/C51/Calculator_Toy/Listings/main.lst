C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /*
   2          æ­£æ•´æ•°è®¡ç®—å™¨:
   3          å…·ä½“åŠŸèƒ½:
   4          1. çŸ©é˜µæŒ‰é”®, å®ç°æ•°æ®ã€è®¡ç®—(=)ã€é‡æ–°è¾“å…¥(å…¨æ¸…)ã€åˆ é™¤(<-)çš„è¾“å…¥
   5              7 8 9 <-
   6              4 5 6 å…¨æ¸…
   7              1 2 3 
   8                0   =
   9              
  10          2. ç‹¬ç«‹æŒ‰é”®, å®ç° + - * / è¾“å…¥
  11              +(K1) -(K2) *(K3) /(K4)
  12          
  13          3. å…ˆè¾“å…¥è¿ç®—ç¬¦å·¦è¾¹æ•°æ®, æœ€é«˜å››ä½ 
  14             å†è¾“å…¥ è¿ç®—ç¬¦
  15             ç„¶åè¾“å…¥è¿ç®—ç¬¦å³è¾¹æ•°æ®, æœ€é«˜å››ä½
  16          
  17          4. æ•°æ®ä»…åœ¨è¾“å…¥æ—¶æ˜¾ç¤º
  18              å·¦è¾¹å››ä¸ª 1ä½æ•°ç ç®¡, ç”¨äºæ˜¾ç¤ºè¿ç®—ç¬¦å·¦å€¼
  19              å³è¾¹å››ä¸ª 1ä¸ºæ•°ç ç®¡, ç”¨äºæ˜¾ç¤ºè¿ç®—ç¬¦å³å€¼
  20              è¿ç®—ç¬¦ ä¸åœ¨æ•°ç ç®¡è¿›è¡Œæ˜¾ç¤º, ç”±LEDè¡¨ç¤º
  21              +, LED1 äº®
  22              -, LED2 äº®
  23              *, LED6 äº®
  24              /, LED7 äº®
  25              =, LED8 äº®
  26          */
  27          
  28          #include <reg52.h>
  29          #include <intrins.h>
  30          
  31          void delayMs() {
  32   1          unsigned char i, j;
  33   1      
  34   1          _nop_();
  35   1          i = 2;
  36   1          j = 199;
  37   1          do {
  38   2              while (--j)
  39   2                  ;
  40   2          } while (--i);
  41   1      }
  42          
  43          void delayNMs(unsigned int n) {
  44   1          while (--n)
  45   1              delayMs();
  46   1      }
  47          
  48          typedef unsigned char u8;
  49          typedef unsigned int u16;
  50          
  51          // LED ç¯
  52          #define LED P2
  53          #define LED1_ON 0xFE
  54          #define LED2_ON 0xFD
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 2   

  55          #define LED6_ON 0xDF
  56          #define LED7_ON 0xBF
  57          #define LED8_0N 0x7F
  58          
  59          // 8ä½æ•°ç ç®¡å¼•è„š
  60          #define SMG P0
  61          
  62          sbit SMG_22 = P2 ^ 2;
  63          sbit SMG_23 = P2 ^ 3;
  64          sbit SMG_24 = P2 ^ 4;
  65          
  66          // çŸ©é˜µæŒ‰é”®
  67          #define KEY_PORT P1
  68          #define KEY_UNPRESS 0
  69          #define KEY1_PRESSED 1
  70          #define KEY2_PRESSED 2
  71          #define KEY3_PRESSED 3
  72          #define KEY4_PRESSED 4
  73          #define KEY5_PRESSED 5
  74          #define KEY6_PRESSED 6
  75          #define KEY7_PRESSED 7
  76          #define KEY8_PRESSED 8
  77          #define KEY9_PRESSED 9
  78          #define KEY10_PRESSED 10
  79          #define KEY11_PRESSED 11
  80          #define KEY12_PRESSED 12
  81          #define KEY13_PRESSED 13
  82          #define KEY14_PRESSED 14
  83          #define KEY15_PRESSED 15
  84          #define KEY16_PRESSED 16
  85          
  86          u8 keyMaps[][4] = {{KEY1_PRESSED, KEY2_PRESSED, KEY3_PRESSED, KEY4_PRESSED},
  87                             {KEY5_PRESSED, KEY6_PRESSED, KEY7_PRESSED, KEY8_PRESSED},
  88                             {KEY9_PRESSED, KEY10_PRESSED, KEY11_PRESSED, KEY12_PRESSED},
  89                             {KEY13_PRESSED, KEY14_PRESSED, KEY15_PRESSED, KEY16_PRESSED}};
  90          
  91          u8 matrixKeyScan(); // 4x4çŸ©é˜µæŒ‰é”® ç¿»è½¬æ‰«æ
  92          
  93          // ç‹¬ç«‹æŒ‰é”®
  94          #define NON_KEY_PUSH 0
  95          #define S_KEY1_PRESSED 1
  96          #define S_KEY2_PRESSED 2
  97          #define S_KEY3_PRESSED 3
  98          #define S_KEY4_PRESSED 4
  99          
 100          sbit S_KEY1 = P3 ^ 1;
 101          sbit S_KEY2 = P3 ^ 0;
 102          sbit S_KEY3 = P3 ^ 2;
 103          sbit S_KEY4 = P3 ^ 3;
 104          
 105          u8 singleKeyScan(); // ç‹¬ç«‹æŒ‰é”®æ‰«æ
 106          
 107          typedef void (*smgSelFunc)(); // æ•°ç ç®¡é€‰æ‹©å‡½æ•° æŒ‡é’ˆ
 108          // 8ä¸ª 1ä½æ•°ç ç®¡é€‰æ‹©å‡½æ•°, ä½é€‰
 109          void smg1();
 110          void smg2();
 111          void smg3();
 112          void smg4();
 113          void smg5();
 114          void smg6();
 115          void smg7();
 116          void smg8();
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 3   

 117          // æ•°ç ç®¡é€‰æ‹©å‡½æ•° æ•°ç»„
 118          smgSelFunc smgFuncs[] = {smg1, smg2, smg3, smg4, smg5, smg6, smg7, smg8};
 119          // æ•°ç ç®¡æ˜¾ç¤ºå€¼ æ•°ç»„, åå…­è¿›åˆ¶ 0~F
 120          u8 smgNum[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x39, 0x5E, 0x79, 0
             -x71, 0x00};
 121          
 122          // æ˜¾ç¤ºå€¼
 123          void valueDisplay();
 124          // æ˜¾ç¤ºç»“æœ
 125          void resultDisplay();
 126          
 127          // NON
 128          #define NON 0
 129          // +
 130          #define ADD 1
 131          // -
 132          #define SUB 2
 133          // *
 134          #define MULTI 3
 135          // /
 136          #define DIV 4
 137          
 138          u8 leftValueArr[4] = {0}; // å·¦å€¼æ•°ç»„
 139          char leftIndex = -1;
 140          
 141          u8 rightValueArr[4] = {0}; // å³å€¼æ•°ç»„
 142          char rightIndex = -1;
 143          
 144          u8 operators = 0;       // æ“ä½œç¬¦
 145          
 146          u8 resultArr[10] = {0}; // ç»“æœæ•°ç»„
 147          char resultIndex = -1;
 148          
 149          // è¾“å…¥è®¡ç®—æ•°
 150          void pushValue(u8 num);
 151          // æ ¹æ®å·¦å€¼ å³å€¼å’Œè¿ç®—ç¬¦è¿›è¡Œè®¡ç®—
 152          void claculateRes();
 153          // å›é€€
 154          void backspace();
 155          
 156          void main() {
 157   1          u8 matrixKeyRes = KEY_UNPRESS; // è®°å½•çŸ©é˜µæŒ‰é”®
 158   1          u8 singleKeyRes = KEY_UNPRESS; // è®°å½•ç‹¬ç«‹æŒ‰é”®
 159   1      
 160   1          while (1) {
 161   2              if (resultIndex != -1) { // æœ‰è®¡ç®—ç»“æœ
 162   3                  resultDisplay();
 163   3              }
 164   2              else { // æ— è®¡ç®—ç»“æœ
 165   3                  valueDisplay();
 166   3              }
 167   2      
 168   2              matrixKeyRes = matrixKeyScan(); // çŸ©é˜µæŒ‰é”®æ‰«æ
 169   2              singleKeyRes = singleKeyScan(); // ç‹¬ç«‹æŒ‰é”®æ‰«æ
 170   2      
 171   2              switch (matrixKeyRes) {
 172   3              case KEY1_PRESSED: // S1  7
 173   3                  pushValue(7);
 174   3                  break;
 175   3              case KEY2_PRESSED: // S2  8
 176   3                  pushValue(8);
 177   3                  break;
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 4   

 178   3              case KEY3_PRESSED: // S3  9
 179   3                  pushValue(9);
 180   3                  break;
 181   3              case KEY5_PRESSED: // S5  4
 182   3                  pushValue(4);
 183   3                  break;
 184   3              case KEY6_PRESSED: // S6  5
 185   3                  pushValue(5);
 186   3                  break;
 187   3              case KEY7_PRESSED: // S7  6
 188   3                  pushValue(6);
 189   3                  break;
 190   3              case KEY9_PRESSED: // S9  1
 191   3                  pushValue(1);
 192   3                  break;
 193   3              case KEY10_PRESSED: // S10  2
 194   3                  pushValue(2);
 195   3                  break;
 196   3              case KEY11_PRESSED: // S11  3
 197   3                  pushValue(3);
 198   3                  break;
 199   3              case KEY14_PRESSED: // S14  0
 200   3                  pushValue(0);
 201   3                  break;
 202   3              case KEY4_PRESSED: // S4 å›é€€
 203   3                  backspace();
 204   3                  break;
 205   3              case KEY8_PRESSED:    // S8 æ¸…ç©º
 206   3                  leftIndex = -1;   // æ¸…ç©ºå·¦å€¼
 207   3                  rightIndex = -1;  // æ¸…ç©ºå³å€¼
 208   3                  resultIndex = -1; // æ¸…ç©ºç»“æœ
 209   3                  operators = 0;    // æ¸…é™¤è¿ç®—ç¬¦
 210   3                  LED = 0xFF;       // ç†„ç­LED
 211   3                  break;
 212   3              case KEY16_PRESSED:  // S16 ç¡®è®¤
 213   3                  LED = LED8_0N;   // äº® = å¯¹åº”çš„ç¯
 214   3                  claculateRes();  // è®¡ç®—ç»“æœ
 215   3                  leftIndex = -1;  // è¯•å›¾ç¡®è®¤ä¹‹å, æ¸…ç©ºå·¦å€¼
 216   3                  rightIndex = -1; // è¯•å›¾ç¡®è®¤ä¹‹å, æ¸…ç©ºå³å€¼
 217   3                  operators = 0;   // æ¸…é™¤è¿ç®—ç¬¦
 218   3                  break;
 219   3      
 220   3              default:
 221   3                  break;
 222   3              }
 223   2      
 224   2              if (rightIndex == -1) {     // å³å€¼å­˜åœ¨, ä¸å†æ”¹å˜è¿ç®—ç¬¦ (ä¹Ÿå¯ä»¥ä¸åšé™åˆ¶)
 225   3                  switch (singleKeyRes) {
 226   4                  case S_KEY1_PRESSED: // K1 +
 227   4                      operators = ADD;
 228   4                      LED = LED1_ON;
 229   4                      break;
 230   4                  case S_KEY2_PRESSED: // K2 -
 231   4                      operators = SUB;
 232   4                      LED = LED2_ON;
 233   4                      break;
 234   4                  case S_KEY3_PRESSED: // K3 *
 235   4                      operators = MULTI;
 236   4                      LED = LED6_ON;
 237   4                      break;
 238   4                  case S_KEY4_PRESSED: // K4 /
 239   4                      operators = DIV;
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 5   

 240   4                      LED = LED7_ON;
 241   4                      break;
 242   4      
 243   4                  default:
 244   4                      break;
 245   4                  }
 246   3              }
 247   2          }
 248   1      }
 249          
 250          u8 matrixKeyScan() {
 251   1          u8 keyRes = KEY_UNPRESS;
 252   1      
 253   1          u8 row = -1; // è¡Œ
 254   1          u8 col = -1; // åˆ—
 255   1          // åˆ— æ‰«æ, P13ä¸ºå·¦æ‰‹ç¬¬ä¸€åˆ—, P17ä¸ºç¬¬ä¸€è¡Œ
 256   1          // å³ P1çš„å…«ä½ä¸­, ä½å››ä½è¡¨ç¤ºåˆ—, é«˜å››ä½è¡¨ç¤ºè¡Œ
 257   1      
 258   1          KEY_PORT = 0x0F;
 259   1          if (KEY_PORT != 0x0F) {
 260   2              delayNMs(10);
 261   2              if (KEY_PORT != 0x0F) {
 262   3                  switch (KEY_PORT) {
 263   4                  case 0x07:
 264   4                      col = 0;
 265   4                      break;
 266   4                  case 0x0B:
 267   4                      col = 1;
 268   4                      break;
 269   4                  case 0x0D:
 270   4                      col = 2;
 271   4                      break;
 272   4                  case 0x0E:
 273   4                      col = 3;
 274   4                      break;
 275   4      
 276   4                  default:
 277   4                      break;
 278   4                  }
 279   3      
 280   3                  KEY_PORT = 0xF0;
 281   3                  switch (KEY_PORT) {
 282   4                  case 0x70:
 283   4                      row = 0;
 284   4                      break;
 285   4                  case 0xB0:
 286   4                      row = 1;
 287   4                      break;
 288   4                  case 0xD0:
 289   4                      row = 2;
 290   4                      break;
 291   4                  case 0xE0:
 292   4                      row = 3;
 293   4                      break;
 294   4      
 295   4                  default:
 296   4                      break;
 297   4                  }
 298   3      
 299   3                  while (KEY_PORT != 0xF0)
 300   3                      ;
 301   3              }
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 6   

 302   2      
 303   2              keyRes = keyMaps[row][col];
 304   2          }
 305   1      
 306   1          return keyRes;
 307   1      }
 308          
 309          u8 singleKeyScan() {
 310   1          u8 keyRes = 0;
 311   1      
 312   1          if (S_KEY1 == 0 || S_KEY2 == 0 || S_KEY3 == 0 || S_KEY4 == 0) {
 313   2              delayNMs(2); // æ¶ˆæŠ–, ç¡®è®¤æ˜¯å¦è¢«æŒ‰ä¸‹
 314   2              if (S_KEY1 == 0)
 315   2                  keyRes = S_KEY1_PRESSED;
 316   2      
 317   2              if (S_KEY2 == 0)
 318   2                  keyRes = S_KEY2_PRESSED;
 319   2      
 320   2              if (S_KEY3 == 0)
 321   2                  keyRes = S_KEY3_PRESSED;
 322   2      
 323   2              if (S_KEY4 == 0)
 324   2                  keyRes = S_KEY4_PRESSED;
 325   2          }
 326   1      
 327   1          while (S_KEY1 == 0 || S_KEY2 == 0 || S_KEY3 == 0 || S_KEY4 == 0)
 328   1              ;
 329   1      
 330   1          // è¿”å›keyRes
 331   1          return keyRes;
 332   1      }
 333          
 334          // æ˜¾ç¤ºå€¼
 335          void valueDisplay() {
 336   1          char i = 0; // valueIndexæ˜¯charç±»å‹çš„, é˜²æ­¢å‘ç”Ÿæ•´å‹æå‡ æ‰€ä»¥iä½¿ç”¨char
 337   1          // å·¦å€¼æ˜¾ç¤º
 338   1          for (i = 0; i <= leftIndex; i++) {
 339   2              smgFuncs[i]();                 // é€‰æ‹©æ•°ç ç®¡
 340   2              SMG = smgNum[leftValueArr[i]]; // æ˜¾ç¤ºæ•°å€¼
 341   2              delayMs();
 342   2              SMG = smgNum[16];
 343   2          }
 344   1          // å³å€¼æ˜¾ç¤º
 345   1          for (i = 0; i <= rightIndex; i++) {
 346   2              smgFuncs[i + 4]();              // é€‰æ‹©æ•°ç ç®¡
 347   2              SMG = smgNum[rightValueArr[i]]; // æ˜¾ç¤ºæ•°å€¼
 348   2              delayMs();
 349   2              SMG = smgNum[16];
 350   2          }
 351   1      }
 352          
 353          // æ˜¾ç¤ºç»“æœ
 354          void resultDisplay() {
 355   1          char i = 0; // valueIndexæ˜¯charç±»å‹çš„, é˜²æ­¢å‘ç”Ÿæ•´å‹æå‡ æ‰€ä»¥iä½¿ç”¨char
 356   1          // ç»“æœæ˜¾ç¤º
 357   1          for (i = 0; i <= resultIndex; i++) {
 358   2              smgFuncs[i]();              // é€‰æ‹©æ•°ç ç®¡
 359   2              SMG = smgNum[resultArr[i]]; // æ˜¾ç¤ºæ•°å€¼
 360   2              delayMs();
 361   2              SMG = smgNum[16];
 362   2          }
 363   1      }
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 7   

 364          
 365          // è¾“å…¥è®¡ç®—æ•°
 366          void pushValue(u8 num) {
 367   1          if (resultIndex != -1) // å¦‚æœä¸Šæ¬¡è®¡ç®—äº†, æŒ‰ä¸‹æ–°æ•° å°±æŠŠç»“æœæ¸…ç©º
 368   1              resultIndex = -1;
 369   1      
 370   1          if (operators) { // å¦‚æœå·²ç»è¾“å…¥äº†è¿ç®—ç¬¦, å°±å¾€å³å€¼æ•°ç»„æ·»åŠ 
 371   2              if (rightIndex < 3)
 372   2                  rightValueArr[++rightIndex] = num;
 373   2          }
 374   1          else { // å¦‚æœæ²¡æœ‰è¾“å…¥è¿ç®—ç¬¦, å°±å¾€å·¦å€¼æ·»åŠ 
 375   2              if (leftIndex < 3)
 376   2                  leftValueArr[++leftIndex] = num;
 377   2          }
 378   1      }
 379          // è®¡ç®—ç»“æœ
 380          void claculateRes() {
 381   1          // å…ˆå°†æ•°å€¼æ•°ç»„ è½¬æ¢ä¸ºæ•°å€¼
 382   1          long leftValue = 0;
 383   1          long rightValue = 0;
 384   1          // è¿™é‡Œé‡åˆ°ä¸€ä¸ªé—®é¢˜
 385   1          // å¦‚æœä½¿ç”¨ int æˆ– unsigned int æ¥æ”¶leftValueå’ŒrightValue
 386   1          // æ˜¯å¯ä»¥æˆåŠŸæ¥æ”¶è¾“å…¥çš„è®¡ç®—æ•°æ®çš„, å› ä¸ºå·¦å€¼å’Œå³å€¼æœ€å¤šåªæœ‰4ä½
 387   1          // 
 388   1          // ä½†æ˜¯, åœ¨åé¢çš„è®¡ç®—ä¸­ä¼šå‘ç”Ÿé”™è¯¯
 389   1          //  Cè¯­è¨€ä¸­, å¦‚æœå°æ•´å‹è¿›è¡Œè®¡ç®—, å¦‚æœè®¡ç®—ç»“æœä¼šä»å°ç±»å‹æº¢å‡º, é‚£ä¹ˆ è®¡ç®—ç»“
             -æœ ä¼š ä¸´æ—¶è‡ªåŠ¨æå‡åˆ° èƒ½å¤Ÿä¸æº¢å‡ºçš„ç±»å‹, 
 390   1          //  ç„¶åå¯ä»¥ç”¨ä»»æ„ç±»å‹è¿›è¡Œæ¥æ”¶, æ¥å—ç»“æœ åªä¼šè¢«æ¥æ”¶æ•°æ®çš„å˜é‡ç±»å‹å½±å“
 391   1          // 
 392   1          //  ä½†, åœ¨C51ä¸­, å¥½åƒå¹¶ä¸æ˜¯è¿™æ ·(ä¹Ÿæˆ–è®¸åªæ˜¯8051è¿™æ ·å¤„ç†)
 393   1          //  C51ä¸­, å³ä½¿ å°æ•´å‹æ•°æ®çš„ è®¡ç®—ç»“æœä¼šæº¢å‡º, è®¡ç®—ç»“æœä¹Ÿå¹¶ä¸ä¼šæå‡ç±»å‹, åª
             -ä¼šè¢«é™åˆ¶åœ¨åŸæœ¬çš„æœ€å¤§ç±»å‹ä¸­
 394   1          //      ä¸¾ä¸ªä¾‹å­, int * int è®¡ç®—ç»“æœçš„ç±»å‹å°±åªä¼šæ˜¯int, èŒƒå›´å°±åªæ˜¯ -32,768 åˆ° 32,7
             -67
 395   1          //       256 * 128çš„ç»“æœæ˜¯ 32768, å¦‚æœåœ¨C51ä¸­ä»¥ intç±»å‹è®¡ç®—, ç»“æœå°±ä¼šæ˜¯0, å› ä¸º 327
             -68 çš„äºŒè¿›åˆ¶æ˜¯ 1000 0000 0000 0000, é¦–ä½æ˜¯ç¬¦å·ä½ åˆšå¥½è¢«æˆªæ–­
 396   1          //       è€Œ 255 * 128çš„ç»“æœæ˜¯ 32640, åœ¨C51ä¸­å°±èƒ½å¤Ÿå®Œæ•´è®¡ç®—å‡ºæ¥
 397   1          //      åŒç†, unsigned int * unsigned intè®¡ç®—ç»“æœçš„ç±»å‹å°±åªä¼šæ˜¯unsigned int, èŒƒå›´å°±åª
             -æ˜¯ 0~65535
 398   1          //       256 * 256çš„ç»“æœæ˜¯65536, åœ¨C51ä¸­ä»¥ unsigned intç±»å‹è®¡ç®—, ç»“æœæ˜¯0, å› ä¸º 65536çš
             -„äºŒè¿›åˆ¶æ˜¯ 1 0000 0000 0000 0000, åˆšå¥½æ¯”4å­—èŠ‚å¤š1ä½
 399   1          //       256 * 255çš„ç»“æœæ˜¯65280, åœ¨C51ä¸­ä»¥ unsigned intç±»å‹è®¡ç®—, ç»“æœèƒ½å¤Ÿå®Œæ•´è®¡ç®—å‡
             -ºæ¥
 400   1      
 401   1          // è¿™ä¸ªé—®é¢˜è®©æˆ‘æƒ³åˆ°å¦å¤–ä¸€ä¸ªé—®é¢˜: C51ä¸­å­˜åœ¨æ•´å‹æå‡å—?
 402   1          //  Cè¯­è¨€ æ•´å‹æå‡, ä¸è¶³4å­—èŠ‚çš„æ•´å‹å˜é‡è¿›è¡Œè®¡ç®—æ—¶, ä¼šå°†åŸæ•°æ®æå‡åˆ°4å­—èŠ‚
             -ç„¶åè¿›è¡Œè®¡ç®—
 403   1          //  ä¹Ÿä¸å¥½è°ƒè¯•
 404   1      
 405   1          long result = 0;
 406   1          long resultTmp = 0;
 407   1      
 408   1          char i = 0;
 409   1          char j = 0;
 410   1      
 411   1          // è®¡ç®—ä¹‹å‰, å…ˆæ¸…é™¤ç»“æœ é˜²æ­¢ä¸Šæ¬¡è®¡ç®—ç»“æœæœªæ¸…é™¤
 412   1          resultIndex = -1;
 413   1      
 414   1          // è½¬å·¦å€¼
 415   1          for (i = 0; i <= leftIndex; i++) {
 416   2              leftValue *= 10;
 417   2              leftValue += leftValueArr[i];
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 8   

 418   2          }
 419   1          // è½¬å³å€¼
 420   1          for (i = 0; i <= rightIndex; i++) {
 421   2              rightValue *= 10;
 422   2              rightValue += rightValueArr[i];
 423   2          }
 424   1      
 425   1          switch (operators) {
 426   2          case ADD:
 427   2              result = leftValue + rightValue;
 428   2              break;
 429   2          case SUB:
 430   2              result = leftValue - rightValue;
 431   2              break;
 432   2          case MULTI:
 433   2              result = leftValue * rightValue;
 434   2              break;
 435   2          case DIV:
 436   2              if (rightValue != 0)
 437   2                  result = leftValue / rightValue;
 438   2              else
 439   2                  result = 0;
 440   2              break;
 441   2          case NON:
 442   2              result = leftValue; // æ²¡æœ‰æ“ä½œç¬¦ç»“æœå°±ç­‰äºå·¦å€¼
 443   2              break;
 444   2      
 445   2          default:
 446   2              break;
 447   2          }
 448   1      
 449   1          // éæ­£æ•´æ•° æ‡’å¾—å¤„ç†äº† ç®€å•çš„å¤„ç†ä¸º0
 450   1          if (result <= 0) {
 451   2              result = 0;
 452   2              resultArr[++resultIndex] = 0;
 453   2              
 454   2              return;
 455   2          }
 456   1      
 457   1          // å°†è®¡ç®—ç»“æœ, å­˜åˆ°resultArrä¸­
 458   1          while (result) {
 459   2              resultTmp = (result % 10); // æ±‚ä¸ªä½
 460   2              result /= 10;              // å»ä¸ªä½
 461   2      
 462   2              resultArr[++resultIndex] = resultTmp; // å¡«æ•°ç»„
 463   2          }
 464   1      
 465   1          // ç¿»è½¬æ•°ç»„
 466   1          i = 0;
 467   1          j = resultIndex;
 468   1          while (i < j) {
 469   2              resultArr[i] = resultArr[i] + resultArr[j];
 470   2              resultArr[j] = resultArr[i] - resultArr[j];
 471   2              resultArr[i] = resultArr[i] - resultArr[j];
 472   2              i++;
 473   2              j--;
 474   2          }
 475   1          // ç»“æœæ•°ç»„è®¡ç®—å®Œæˆ
 476   1      }
 477          // å›é€€
 478          void backspace() {
 479   1          if (operators) { // å¦‚æœå·²ç»è¾“å…¥äº†è¿ç®—ç¬¦, å°±å›é€€å³å€¼
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 9   

 480   2              if (rightIndex >= 0)
 481   2                  rightIndex--;
 482   2          }
 483   1          else { // å¦‚æœæ²¡æœ‰è¾“å…¥è¿ç®—ç¬¦, å°±å›é€€å·¦å€¼
 484   2              if (leftIndex >= 0)
 485   2                  leftIndex--;
 486   2          }
 487   1      }
 488          
 489          // 8ä¸ª 1ä½æ•°ç ç®¡é€‰æ‹©å‡½æ•°
 490          void smg1() {
 491   1          SMG_24 = 1;
 492   1          SMG_23 = 1;
 493   1          SMG_22 = 1;
 494   1      }
 495          
 496          void smg2() {
 497   1          SMG_24 = 1;
 498   1          SMG_23 = 1;
 499   1          SMG_22 = 0;
 500   1      }
 501          
 502          void smg3() {
 503   1          SMG_24 = 1;
 504   1          SMG_23 = 0;
 505   1          SMG_22 = 1;
 506   1      }
 507          
 508          void smg4() {
 509   1          SMG_24 = 1;
 510   1          SMG_23 = 0;
 511   1          SMG_22 = 0;
 512   1      }
 513          
 514          void smg5() {
 515   1          SMG_24 = 0;
 516   1          SMG_23 = 1;
 517   1          SMG_22 = 1;
 518   1      }
 519          
 520          void smg6() {
 521   1          SMG_24 = 0;
 522   1          SMG_23 = 1;
 523   1          SMG_22 = 0;
 524   1      }
 525          
 526          void smg7() {
 527   1          SMG_24 = 0;
 528   1          SMG_23 = 0;
 529   1          SMG_22 = 1;
 530   1      }
 531          
 532          void smg8() {
 533   1          SMG_24 = 0;
 534   1          SMG_23 = 0;
 535   1          SMG_22 = 0;
 536   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1300    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              09/27/2024 19:40:48 PAGE 10  

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     79      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
